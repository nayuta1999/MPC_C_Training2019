\section{演習問題}
\subsection{問1}
int *p=a;配列aの先頭の要素を表すポインタ
p+=4;をすると、配列のaの先頭の要素から4番目のポインタを意味するようになる。
(*p)++;は、そのポインタがさす要素の値を+1する。
printfは*--p +5なので、+1した値は関係なく、その手前の要素+5が出力される。
\subsubsection{解説}

\section{演習問題}
\subsection{問2}
*pは配列の先頭から4番目の値を指すポインタである。
そこから2つ前の要素の値を指すポインタになり、その要素が+1される。
最後に、1つ前のポインタと、aの2番目の値の和が出力される。
\subsubsection{解説}

\section{演習問題}
\subsection{問3}
\subsubsection{解説}
問1,2と同様にしてポインタは動く。
しかし、フォーマット指定子が%dであることに注意していただきたい。
これは、配列内の2進数表記された値を10進数の整数値として出力せよという命令を意味しており、
double型で表された値をint型で出力しようとすると、意味不明な値が出てくる。
浮動小数点を使った少数も扱える型のデータを無理やりint型で出力しているので、変な値が出てきた。
出力される数字が何かは、double型の要素を浮動小数点で表してみれば予測できる。
これが理解できれば、0が格納されている値を%dで出力すれば、0と出力されることが予測できるだろう。
(ポインタを扱う上で、ここまで理解している必要はありません。この問題は理解できなくても、今のうちは問題ないです。)

\section{演習問題}
\lstinputlisting{\codepath/sakaki/answer4.c}
\subsection{問4}
素数判定をif文に入れることで、簡単に場合分けが出来る。
実際に書くべきなのはfor文程度なので、意外と簡単に実装出来たのではないだろうか。
エラトステネスの篩は、そこそこ難しいアルゴリズムなので、興味があれば調べる程度で良い。
\subsubsection{解説}
